KR_VOID 1 void
IDN 1 foo
L_ZAGRADA 1 (
KR_INT 1 int
IDN 1 x
ZAREZ 1 ,
KR_INT 1 int
IDN 1 c
ZAREZ 1 ,
KR_CHAR 1 char
IDN 1 h
D_ZAGRADA 1 )
L_VIT_ZAGRADA 2 {
KR_INT 3 int
IDN 3 i
OP_PRIDRUZI 3 =
IDN 3 fact
L_ZAGRADA 3 (
IDN 3 x
D_ZAGRADA 3 )
TOCKAZAREZ 3 ;
KR_INT 4 int
IDN 4 a
OP_PRIDRUZI 4 =
IDN 4 a
PLUS 4 +
BROJ 4 1
TOCKAZAREZ 4 ;
KR_VOID 5 void
IDN 5 foo3
L_ZAGRADA 5 (
KR_VOID 5 void
D_ZAGRADA 5 )
TOCKAZAREZ 5 ;
KR_INT 6 int
IDN 6 niz1
L_UGL_ZAGRADA 6 [
BROJ 6 5
D_UGL_ZAGRADA 6 ]
OP_PRIDRUZI 6 =
L_VIT_ZAGRADA 6 {
BROJ 6 1
ZAREZ 6 ,
BROJ 6 2
ZAREZ 6 ,
BROJ 6 3
D_VIT_ZAGRADA 6 }
TOCKAZAREZ 6 ;
KR_FOR 9 for
L_ZAGRADA 9 (
IDN 9 i
OP_PRIDRUZI 9 =
BROJ 9 0
TOCKAZAREZ 9 ;
IDN 9 i
OP_LT 9 <
BROJ 9 5
TOCKAZAREZ 9 ;
IDN 9 i
OP_INC 9 ++
D_ZAGRADA 9 )
KR_BREAK 10 break
TOCKAZAREZ 10 ;
KR_WHILE 11 while
L_ZAGRADA 11 (
BROJ 11 1
D_ZAGRADA 11 )
L_VIT_ZAGRADA 12 {
KR_BREAK 13 break
TOCKAZAREZ 13 ;
IDN 14 i
OP_PRIDRUZI 14 =
IDN 14 i
PLUS 14 +
BROJ 14 2
TOCKAZAREZ 14 ;
D_VIT_ZAGRADA 15 }
KR_RETURN 17 return
TOCKAZAREZ 17 ;
KR_BREAK 18 break
TOCKAZAREZ 18 ;
D_VIT_ZAGRADA 19 }
