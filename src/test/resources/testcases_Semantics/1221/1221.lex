KR_VOID 1 void
IDN 1 foo
L_ZAGRADA 1 (
KR_INT 1 int
IDN 1 x
ZAREZ 1 ,
KR_INT 1 int
IDN 1 c
ZAREZ 1 ,
KR_CHAR 1 char
IDN 1 h
D_ZAGRADA 1 )
L_VIT_ZAGRADA 2 {
KR_INT 3 int
IDN 3 a
OP_PRIDRUZI 3 =
IDN 3 a
PLUS 3 +
BROJ 3 1
TOCKAZAREZ 3 ;
KR_VOID 4 void
IDN 4 foo3
L_ZAGRADA 4 (
KR_VOID 4 void
D_ZAGRADA 4 )
TOCKAZAREZ 4 ;
KR_INT 5 int
IDN 5 niz1
L_UGL_ZAGRADA 5 [
BROJ 5 5
D_UGL_ZAGRADA 5 ]
OP_PRIDRUZI 5 =
L_VIT_ZAGRADA 5 {
BROJ 5 1
ZAREZ 5 ,
BROJ 5 2
ZAREZ 5 ,
BROJ 5 3
D_VIT_ZAGRADA 5 }
TOCKAZAREZ 5 ;
KR_FOR 8 for
L_ZAGRADA 8 (
IDN 8 i
OP_PRIDRUZI 8 =
BROJ 8 0
TOCKAZAREZ 8 ;
IDN 8 i
OP_LT 8 <
BROJ 8 5
TOCKAZAREZ 8 ;
IDN 8 i
OP_INC 8 ++
D_ZAGRADA 8 )
KR_BREAK 9 break
TOCKAZAREZ 9 ;
KR_WHILE 10 while
L_ZAGRADA 10 (
BROJ 10 1
D_ZAGRADA 10 )
L_VIT_ZAGRADA 11 {
KR_BREAK 12 break
TOCKAZAREZ 12 ;
IDN 13 i
OP_PRIDRUZI 13 =
IDN 13 i
PLUS 13 +
BROJ 13 2
TOCKAZAREZ 13 ;
D_VIT_ZAGRADA 14 }
KR_RETURN 16 return
TOCKAZAREZ 16 ;
KR_BREAK 17 break
TOCKAZAREZ 17 ;
D_VIT_ZAGRADA 18 }
