KR_VOID 15 void
IDN 15 fun
L_ZAGRADA 15 (
KR_INT 15 int
IDN 15 a
L_UGL_ZAGRADA 15 [
D_UGL_ZAGRADA 15 ]
D_ZAGRADA 15 )
L_VIT_ZAGRADA 15 {
KR_RETURN 16 return
TOCKAZAREZ 16 ;
D_VIT_ZAGRADA 17 }
KR_INT 19 int
IDN 19 main
L_ZAGRADA 19 (
KR_VOID 19 void
D_ZAGRADA 19 )
L_VIT_ZAGRADA 19 {
KR_INT 20 int
IDN 20 A
L_UGL_ZAGRADA 20 [
BROJ 20 512
D_UGL_ZAGRADA 20 ]
TOCKAZAREZ 20 ;
KR_INT 21 int
IDN 21 t
L_UGL_ZAGRADA 21 [
BROJ 21 1
D_UGL_ZAGRADA 21 ]
OP_PRIDRUZI 21 =
L_VIT_ZAGRADA 21 {
BROJ 21 1
ZAREZ 21 ,
BROJ 21 2
ZAREZ 21 ,
BROJ 21 3
D_VIT_ZAGRADA 21 }
TOCKAZAREZ 21 ;
KR_CONST 22 const
KR_CHAR 22 char
IDN 22 tmp
L_UGL_ZAGRADA 22 [
D_UGL_ZAGRADA 22 ]
OP_PRIDRUZI 22 =
NIZ_ZNAKOVA 22 "te  \nst"
TOCKAZAREZ 22 ;
KR_INT 23 int
IDN 23 xYz
ZAREZ 23 ,
IDN 23 abc
TOCKAZAREZ 23 ;
IDN 25 xYz
OP_PRIDRUZI 25 =
BROJ 25 12345
TOCKAZAREZ 25 ;
IDN 26 abc
OP_PRIDRUZI 26 =
IDN 26 xYz
TOCKAZAREZ 26 ;
IDN 27 abc
OP_PRIDRUZI 27 =
IDN 27 abc
OP_INC 27 ++
PLUS 27 +
IDN 27 xYz
TOCKAZAREZ 27 ;
IDN 28 abc
OP_PRIDRUZI 28 =
BROJ 28 1
PLUS 28 +
BROJ 28 2
OP_PUTA 28 *
BROJ 28 3
OP_BIN_ILI 28 |
BROJ 28 4
OP_BIN_I 28 &
BROJ 28 5
TOCKAZAREZ 28 ;
KR_FOR 30 for
L_ZAGRADA 30 (
IDN 30 i
OP_PRIDRUZI 30 =
BROJ 30 0
TOCKAZAREZ 30 ;
IDN 30 i
OP_LT 30 <
BROJ 30 4
TOCKAZAREZ 30 ;
OP_INC 30 ++
IDN 30 i
D_ZAGRADA 30 )
L_VIT_ZAGRADA 30 {
IDN 31 tmp
L_UGL_ZAGRADA 31 [
IDN 31 i
D_UGL_ZAGRADA 31 ]
OP_PRIDRUZI 31 =
L_ZAGRADA 31 (
KR_CHAR 31 char
D_ZAGRADA 31 )
IDN 31 abc
TOCKAZAREZ 31 ;
KR_CONTINUE 32 continue
TOCKAZAREZ 32 ;
D_VIT_ZAGRADA 33 }
KR_IF 35 if
L_ZAGRADA 35 (
BROJ 35 1
OP_GTE 35 >=
BROJ 35 3
OP_I 35 &&
IDN 35 i
OP_GT 35 >
BROJ 35 2
D_ZAGRADA 35 )
IDN 36 fun
L_ZAGRADA 36 (
BROJ 36 35
D_ZAGRADA 36 )
TOCKAZAREZ 36 ;
KR_ELSE 37 else
KR_IF 37 if
L_ZAGRADA 37 (
IDN 37 i
OP_LT 37 <
BROJ 37 12
D_ZAGRADA 37 )
IDN 38 fun
L_ZAGRADA 38 (
BROJ 38 5
D_ZAGRADA 38 )
TOCKAZAREZ 38 ;
KR_ELSE 39 else
IDN 40 fun
L_ZAGRADA 40 (
BROJ 40 123
D_ZAGRADA 40 )
TOCKAZAREZ 40 ;
KR_RETURN 42 return
BROJ 42 0
TOCKAZAREZ 42 ;
D_VIT_ZAGRADA 43 }
