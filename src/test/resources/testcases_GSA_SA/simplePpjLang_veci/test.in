KR_VOID 1 void
IDN 1 fun
L_ZAGRADA 1 (
KR_INT 1 int
IDN 1 a
L_UGL_ZAGRADA 1 [
D_UGL_ZAGRADA 1 ]
D_ZAGRADA 1 )
L_VIT_ZAGRADA 1 {
KR_RETURN 2 return
TOCKAZAREZ 2 ;
D_VIT_ZAGRADA 3 }
KR_INT 5 int
IDN 5 main
L_ZAGRADA 5 (
KR_VOID 5 void
D_ZAGRADA 5 )
L_VIT_ZAGRADA 5 {
KR_INT 6 int
IDN 6 A
L_UGL_ZAGRADA 6 [
BROJ 6 512
D_UGL_ZAGRADA 6 ]
TOCKAZAREZ 6 ;
KR_INT 7 int
IDN 7 t
L_UGL_ZAGRADA 7 [
D_UGL_ZAGRADA 7 ]
OP_PRIDRUZI 7 =
L_VIT_ZAGRADA 7 {
BROJ 7 1
ZAREZ 7 ,
BROJ 7 2
ZAREZ 7 ,
BROJ 7 3
D_VIT_ZAGRADA 7 }
TOCKAZAREZ 7 ;
KR_CONST 8 const
KR_CHAR 8 char
IDN 8 tmp
L_UGL_ZAGRADA 8 [
D_UGL_ZAGRADA 8 ]
OP_PRIDRUZI 8 =
NIZ_ZNAKOVA 8 "te  \nst"
TOCKAZAREZ 8 ;
KR_INT 9 int
IDN 9 xYz
ZAREZ 9 ,
IDN 9 abc
TOCKAZAREZ 9 ;
IDN 11 xYz
OP_PRIDRUZI 11 =
BROJ 11 12345
TOCKAZAREZ 11 ;
IDN 12 abc
OP_PRIDRUZI 12 =
IDN 12 xYz
TOCKAZAREZ 12 ;
IDN 13 abc
OP_PRIDRUZI 13 =
IDN 13 abc
OP_INC 13 ++
PLUS 13 +
IDN 13 xYz
TOCKAZAREZ 13 ;
IDN 14 abc
OP_PRIDRUZI 14 =
BROJ 14 1
PLUS 14 +
BROJ 14 2
OP_PUTA 14 *
BROJ 14 3
OP_BIN_ILI 14 |
BROJ 14 4
OP_BIN_I 14 &
BROJ 14 5
TOCKAZAREZ 14 ;
KR_FOR 16 for
L_ZAGRADA 16 (
IDN 16 i
OP_PRIDRUZI 16 =
BROJ 16 0
TOCKAZAREZ 16 ;
IDN 16 i
OP_LT 16 <
BROJ 16 4
TOCKAZAREZ 16 ;
OP_INC 16 ++
IDN 16 i
D_ZAGRADA 16 )
L_VIT_ZAGRADA 16 {
IDN 17 tmp
L_UGL_ZAGRADA 17 [
IDN 17 i
D_UGL_ZAGRADA 17 ]
OP_PRIDRUZI 17 =
L_ZAGRADA 17 (
KR_CHAR 17 char
D_ZAGRADA 17 )
IDN 17 abc
TOCKAZAREZ 17 ;
KR_CONTINUE 18 continue
TOCKAZAREZ 18 ;
D_VIT_ZAGRADA 19 }
KR_IF 21 if
L_ZAGRADA 21 (
BROJ 21 1
OP_GTE 21 >=
BROJ 21 3
OP_I 21 &&
IDN 21 i
OP_GT 21 >
BROJ 21 2
D_ZAGRADA 21 )
IDN 22 fun
L_ZAGRADA 22 (
BROJ 22 35
D_ZAGRADA 22 )
TOCKAZAREZ 22 ;
KR_ELSE 23 else
KR_IF 23 if
L_ZAGRADA 23 (
IDN 23 i
OP_LT 23 <
BROJ 23 12
D_ZAGRADA 23 )
IDN 24 fun
L_ZAGRADA 24 (
BROJ 24 5
D_ZAGRADA 24 )
TOCKAZAREZ 24 ;
KR_ELSE 25 else
IDN 26 fun
L_ZAGRADA 26 (
BROJ 26 123
D_ZAGRADA 26 )
TOCKAZAREZ 26 ;
KR_RETURN 28 return
BROJ 28 0
TOCKAZAREZ 28 ;
D_VIT_ZAGRADA 29 }
